# 1. 내장 함수

- SQL의 함수는 크게 두 가지로 나뉨.
  - DBMS가 제공하는 내장 함수(built-in function)
  - 사용자가 필요에 따라 직접 만드는 사용자 정의 함수(user-defined function)

### 1. SQL 내장 함수

- SQL 내장 함수는 상수나 속성 이름을 입력 값으로 받아 단일 값을 결과로 반환한다.
- SELECT절, WHERE절, UPDATE절 모두 사용가능하다.

| 구분                       |                      | 함수                                                                                                     |
| -------------------------- | -------------------- | -------------------------------------------------------------------------------------------------------- |
| 단일행함수                 | 숫자함수             | ABS, CEIL, COS, EXP, FLOOR, LN, LOG, MOD, POWER, RAND, ROUND, SIGN, TRUNCATE                             |
|                            | 문자함수(문자 변환)  | CHAR, CONCAT, LEFT, RIGHT, LOWER, UPPER, LPAD, RPAD, LTRIM, RTRIM, REPLACE, REVERSE, RIGHT, SUBSTR, TRIM |
|                            | 문자 함수(숫자 변환) | ASCII, INSTR, LENGTH                                                                                     |
|                            | 날짜, 시간 함수      | ADDDATE, CURRENT_DATE, DATE, DATEDIFF, DAYNAME, LAST_DAY, SYSDATE, TIME                                  |
|                            | 변환 함수            | CAST, CONVERT, DATE_FORMAT, STR_TO_DATE                                                                  |
|                            | 정보 함수            | DATABASE, SCHEMA, ROW_COUNR, USER, VERSION                                                               |
|                            | NULL 관련 함수       | COALESCE, ISNULL, IFNULL, NULLIF                                                                         |
| 집계 함수                  |                      | AVG, COUNT, MAX, MIN, STD, STDDEV, SUM                                                                   |
| 윈도우 함수(혹은 분석 함수 |                      | CUME_DIST, DENSE_RANK, FIRST_VALUE, LAST_VALUE, LEAD, NTILE, RANK, ROW_NUMBER                            |

### 숫자 함수

SQL 문에서 수학의 기본적인 사칙 연산자와 나머지 연산자 기호를 그대로 사용

- ABS(숫자) : 숫자의 절댓값을 계산
- CEIL(숫자) : 숫자보다 크거나 같은 최소의 정수
- FLOOR(숫자) : 숫자보다 작거나 같은 최소의 정수
- ROUND(숫자, m) : 숫자의 반올림, m은 반올림 기준 자릿수
- LOG(n, 숫자) : 숫자의 자연로그 값을 반환
- POWER(숫자, n) : 숫자의 n제곱 값을 계산
- SORT(숫자) : 숫자의 제곱근 값을 계산(숫자는 양수)
- SIGN(숫자) : 숫자가 음수면 -1, 0이면 0, 양수면 1

### 문자 함수

문자 함수는 주로 CHAR나 VARCHAR의 데이터 타입을 대상으로 단일 문자나 문자열을 가공한 결과를 반환한다.

- 문자값 반환 함수
  - CONCAT(s1, s2) : 두 문자열을 연결
  - LOWER(s) : 대상 문자열을 모두 소문자로 변환
  - LPAD(s,n,c) : 대상 문자열의 왼쪽부터 지정한 자리수까지 지정한 문자로 채움
  - REPLACE(s1,s2,s3) : 대상 문자열의 지정한 문자를 원하는 문자로 변경
  - RPAD(s,n,c) : 대상 문자열의 오른쪽부터 지정한 자리수까지 지정한 문자로 채움
  - SUBSTR(s,n,k) : 대상 문자열의 지정된 자리에서부터 지정된 길이만틈 잘라서 반환
  - TRIM(c FROM s) : 대상 문자열의 양쪽에서 지정된 문자를 삭제
  - UPPER(s) : 대상 문자열을 모두 대문자로 변환
- 숫자값 반환 함수
  - ASCII(c) : 대상 알파벳 문자의 아스키 코드 값을 반환
  - LENGTH(s) : 대상 문자열의 Byte 반환, 알파벳 1byte, 한글 3byte(UTF-8)
  - CHAR_LENGTH(s) : 문자열의 문자 수를 반환

s: 문자열, c : 문자, n : 정수, k : 정수

### 날짜, 시간 함수

날짜, 시간 함수에서 날짜와 시간 부분을 나타내는 인수는 ‘format’으로 표기한다. ex) 년도 ‘%Y’, 월 ‘%m’, 일 ‘%d’

- STR_TO_DATE(string,format) : 문자열 데이터를 날짜형으로 변환
- DATE_FORMAT(date, format) : 날짜형 데이터를 문자열로 변환
- ADDDATE(date, interval) : DATE형의 날짜에서 INTERVAL 지정한 시간만큼 더함
- DATE(date) : DATE형의 날짜 부분을 반환
- DATEDIFF(date1, date2) : DATE 형의 date1 - date2 날짜 차이를 반환
- SYSDATE : DBMS 시스템상의 오늘 날짜를 반환하는 함수
- format의 주요 지정자

| 인자 | 설명                      |
| ---- | ------------------------- |
| %w   | 요일 순서(0~6, Sunday=0)  |
| %W   | 요일(Sunday~Saturday)     |
| %a   | 요일의 약자(Sun~Sat)      |
| %d   | 1달 중 날짜(00~31)        |
| %j   | 1년 중 날짜(001~366)      |
| %h   | 12시간(0~12)              |
| %H   | 24시간(0~24)              |
| %i   | 분(0~59)                  |
| %m   | 월 순서(01~12)            |
| %b   | 월 이름 약어(Jan~Dec)     |
| %M   | 월 이름(January~December) |
| %s   | 초(0~59)                  |
| %Y   | 4자리 연도                |
| %y   | 4자리 연도의 마지막 2자리 |

### 2. NULL 값 처리

NULL 값이란 아직 지정되지 않은 값을 말한다. 0, 빈문자, 공백과는 다른 특별한 값이고, =, >, <등과 같은 연산자로 비교하지 못한다.

### NULL값에 대한 연산과 집계 함수

NULL값이 포함된 행에 대해 다음과 같은 주의가 필요하다.

- NULL+숫자 연산의 결과는 NULL이다.
- 집계 함수를 계산할 때 NULL이 포함된 행은 집계에서 빠진다.
- 해당되는 행이 하나도 없을 경우 SUM, AVG 함수의 결과는 NULL이 되고, COUNT 함수의 결과는 0이다.

### NULL 값을 확인하는 방법 - IS NULL, IS NOT NULL

- NULL값을 찾을 때는 ‘=’연산자가 아닌 ‘IS NULL’을 사용하고, NULL이 아닌 값을 찾을 때는 ‘<>’연산자가 아닌 ‘IS NOT NULL’을 사용한다.

### IFNULL함수

- IFNULL함수는 NULL값을 다른 값으로 대치하여 연산하거나 다른 값으로 출력하는 함수이다. IFNULL함수를 사용하면 NULL값을 임의의 다른 값으로 변경할 수 있다.
- IFNULL(속성, 값) // 속성 값이 NULL이면 ‘값’으로 대치한다.

### 3. 행번호 출력

행에 번호를 붙이거나 행번호에 따라 결과의 개수를 조절하는 방법

- MySQL에서 변수는 이름 앞에 @기호를 붙이며 치환문에는 SET과 :=기호를 사용한다.

```sql
SET @seq:=0;
SELECT (@seq:=@seq+1) '순번', custid, name, phone
FROM Customer
WHERE @seq<2;
```

---

# 2. 부속질의

- 부속질의(subquery)는 하나의 SQL문 안에 다른 SQL문이 중첩된(nested)질의를 말한다.
- Orders 테이블과 Customer테이블을 연관시켜 데이터를 찾아야 할 때 두 가지 방법이 있다.
  - **조인을 사용할 경우** : Customer테이블과 Orders테이블의 고객번호로 조인한 후 필요한 데이터를 추출한다.
  - **부속질의를 사용할 경우** : Customer테이블에서 박지성 고객의 고객번호를 찾고, 찾은 고객번호를 바탕으로 Orders테이블에서 확인한다.

→ 데이터만 찾아서 공급해주는 부속질의의 성능이 더 좋다.

- 부속질의 세 가지
  | 명칭 | 위치 | 설명 |
  | --------------- | --------- | ---------------------------------------------------------------------------------------- |
  | 스칼라 부속질의 | SELECT 절 | SELECT절에서 사용되며 단일 값을 반환하기 때문에 스칼라 부속질의라고 한다 |
  | 인라인 뷰 | FROM 절 | FROM절에서 결과를 뷰 형태로 반환하기 때문에 인라인 뷰라고 한다. |
  | 중첩질의 | WHERE절 | WHERE절에 술어와 같이 사용되며 결과를 한정시키기 위해 사용된다. 상관 혹은 비상관 형태다. |
  - 동작 방식
    - 상관 부속질의 : 주질의의 특정 열 값을 부속질의가 상속받아 부속질의의 질의에 사용하는 형태
    - 비상관 부속질의(일반 부속질의) : 독립된 질의를 수행해서 결과 값을 가져오는 형태이다.
  - 반환하는 결과의 형태
    - 단일행 부속질의 : 부속질의의 결과 하나의 행을 반환하여 주질의에 전달한다.
    - 다중행 부속질의 : 부속질의의 결과 여러 개의 행을 반환한다.

### 1. 스칼라 부속질의 - SELECT 부속질의

- 스칼라 부속질의 예
  - 마당서점의 고객별 판매액을 보이시오(고객이름과 고객별 판매액 출력)

```sql
SELECT (SELECT name
        FROM Customer cs
        WHERE cs.custid = od.custid) 'name', SUM(saleprice) 'total'
FROM    Orders od
GROUP BY od.custid;
```

- 새로운 속성을 추가해주고 데이터 값을 입력해줄 때
  - ex) Orders 테이블에 각 주문에 맞는 도서이름을 입력하시오.

```sql
ALTER TABLE Orders ADD bname VARCHAR(40);

UPDATE Orders
SET bname=(SELECT bookname
           FROM Book
           WHERE Book.bookid = Orders.bookid);
```

### 2. 인라인 뷰 - FROM 부속질의

인라인 뷰(inline view)는 FROM절에서 사용되는 부속질의를 말한다.

FROM에 테이블 대신 인라인 뷰 부속질의를 사용하면 보통의 테이블과 같은 형태로 사용할 수 있다.

```sql
SELECT cs.name, SUM(od.saleprice) 'total'
FROM (SELECT custid, name
      FROM   Customer
      WHERE custid <= 2) cs,
      Orders od
WHERE cs.custid = od.custid
GROUP BY cs.name;
```

→ 인라인 뷰를 사용하면 필요한 데이터만 뽑아 사용할 수 있으므로 처리 성능을 높일 수 있다.

### 3. 중첩질의 - WHERE 부속질의

중첩질의(nested query)는 WHERE절에서 사용되는 부속질의를 말한다.

연산 결과에 따라 WHERE 절의 조건이 참인지 거짓인지 확인하여 참일 경우 주질의의 해당 행을 출력한다.

- 비교 연산자

  - 부속질의가 단일 행, 단일 열을 반환할 때 사용 가능하다.

- IN, NOT IN

  - 결과로 다중 행, 다중 열을 반환할 수 있다.
  - IN 연산자는 주질의의 속성 값이 부속질의에서 제공한 결과 집합에 있는지 확인하는 역할. 값이 하나라도 있으면 참이다.
  - NOT IN은 값이 존재하지 않으면 참이 된다.

- ALL, SOME(ANY)

  - ALL, SOME(ANY)연산자는 비교 연산자와 함께 사용된다.
  - ALL은 모든, SOME(ANY)는 최소한 하나라는 의미를 가진다.
  - ALL은 결과 집합의 최댓값
  - SOME(ANY)는 결과 집합 중 최솟값

- EXISTS, NOT EXISTS
  - 데이터의 존재 유무를 확인하는 연산자이다.
  - 부속질의에 조건을 만족하여 값이 존재하면 참이 되고, 주질의는 해당 행의 데이터를 출력한다.

---

# 3. 뷰

- 뷰(view)는 하나 이상의 테이블을 합하여 만든 가상의 테이블이다. 합한다는 말은 앞서 배운 SELECT 문을 통해 얻은 최종 결과를 뜻하며, 뷰는 이런 결과를 가상의 테이블로 정의하여 실제 테이블처럼 사용할 수 있도록 만든 데이터베이스 개체이다.
- 뷰 생성문

```sql
CREATE VIEW Vorders
AS SELECT orderid, O.custid, name, O.bookid, bookname, saleprice, orderdate
FROM      Customer C, Orders O, Book B
WHERE     C.custid= O.custid and B.bookid = O.bookid;
```

- 뷰의 장점
  - 편리성 및 재사용성 : 미리 정의된 뷰를 일반 테이블처럼 사용할 수 있기 때문에 편리하다. 자주 사용되는 질의를 뷰로 미리 정의해 재사용할 수 있다.
  - 보안성 : 사용자별로 보안이 필요한 데이터를 제외하여 선별하여 보여줄 수 있다.
  - 독립성 : 원본 테이블의 구조가 변해도 응용 프로그램에 영향을 주지 않도록 하는 논리적 독립성을 제공하는 방법이다.

### 1. 뷰의 생성

- 뷰는 사용자가 직접 정의하는 과정을 거치는데, 뷰의 정의를 생성이라고도 한다.

```sql
CREATE VIEW 뷰이름 [(열이름[,,,n])]
AS SELECT 문
```

- 뷰이름 : 생성할 뷰 이름
- 열이름 : 뷰에서 사용할 열의 이름
  - 열 이름과 SELECT문에서 추출하는 속성은 일대일로 대응된다.
- SELECT문은 뷰를 정의하는 역할.

- 뷰는 실제 데이터가 저장되는 게 아니라 뷰의 정의가 DBMS에 저장되는 것이다.

### 2. 뷰의 수정

뷰의 수정은 CREATE VIEW문에 OR REPLACE 명령을 더하여 작성한다.

```sql
CREATE OR REPLACE VIEW 뷰이름 [(열이름[,,,n])]
AS SELECT문
```

→ 기존에 있던 뷰를 변경하는 것

### 3. 뷰의 삭제

```sql
DROP VIEW 뷰이름 [.... n];
```

---

# 4. 인덱스

### 1. 데이터베이스의 물리적 저장

데이터 엑세스 시간 = 탐색시간 (엑세스 헤드를 트랙에 이동시키는 시간\_

                               +회전 지연시간(섹터가 엑세스 헤드에 접근하는 시간)

                          + 데이터 전송시간(데이터를 주기억장치로 읽어오는 시간)

- 디스크의 엑세스 속도가 느린 것을 줄이기 위해 주기억장치에 DBMS가 사용하는 공간 중 일부를 버퍼 풀(Buffer Pool Memory)로 만들어 사용하는 방법이 있다. DB는 버퍼에 자주 사용하는 데이터를 저장해두며 LRU(Least Recently Used)알고리즘을 이용하여 사용빈도가 높은 데이터 위주로 저장하고 관리한다.

  - LRU알고리즘 : 기억장소를 관리하는 알고리즘으로 최근에 사용되지 않은 순서대로 기억 장소에서 할당을 제외하는 방법이다.

- DBMS는 데이터베이스별로 하나 이상의 파일을 생성한다. 테이블은 생성 시 정의된 내용에 따라 논리적으로 구분지어 각각의 데이터 파일에 저장한다.

- MySQL의 저장장치 엔진은 InnoDB엔진이 기본으로 설치되어 있다.
- MySQL InnoDB는 사용하는 데이터베이스별로 별도의 파일을 생성한다.
  - 데이터 파일
    - 사용자 데이터와 개체를 저장
    - 테이블과 인덱스로 구성
    - 확장자는 .ibd
  - 폼 파일
    - 테이블에 대한 각종 정보와 테이블을 구성하는 필드, 데이터 타입에 대한 정보 저장
    - 데이터베이스 구조 등의 변경사항이 있을 때 자동으로 업데이트 됨

### 2. 인덱스와 B-tree

인덱스(index)란 자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.

- 데이터베이스에서 인덱스 : 원하는 데이터를 빨리 찾기 위해 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조이다.
- 일반적인 RDBMS의 인덱스 구조 : B-tree(Balanced-tree)

  - B-tree : 데이터의 검색 시간을 단축하기 위한 자료구조
    - 루트 노드(root node)
    - 내부노드(internal node)
    - 리프노드(leaf node)
  - 리프 노드가 모두 같은 레벨에 존재하는 균형 트리이다.

- 루트 노드에서 값을 비교하고 내부 노드에서 해당 노드를 찾고 없으면 리프 노드에 도달한다. 리프 노드에는 해당 데이터의 저장 위치에 대응하는 rowid(RID, Row IDentify, 테이블의 행에 대한 논리적 위치)를 가지고 있어 찾고자 하는 행을 바로 찾을 수 있다.

- 인덱스 특징
  - 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성
  - 빠른 검색과 함께 효율적인 레코드 접근
  - 순서대로 정렬된 속성과 데이터의 위치만 보유하므로 테이블보다 작은 공간을 차지한다.
  - 저장된 값들은 테이블의 부분집합이 된다.
  - 일반적으로 B-tree 형태의 구조를 가진다.
  - 데이터의 수정, 삭제 등의 변경이 발생하면 인덱스의 재구성이 필요

### 3. MySQL인덱스

클러스터 인덱스와 보조 인덱스가 같이 사용된다.

| 인덱스 명칭     | 설명                                                                                              |
| --------------- | ------------------------------------------------------------------------------------------------- |
| 클러스터 인덱스 | - 기본적인 인덱스로 테이블 생성 시 기본키를 지정하면 기본 키에 대하여 클러스터 인덱스를 생성한다. |

- 기본키를 지정하지 않으면 먼저 나오는 UNIQUE속성에 대해 클러스터 인덱스를 생성
- 기본키나 UNIQUE 속성이 없는 테이블은 MySQL이 자체 생성한 행번호를 이용하여 클러스터 인덱스를 생성 |
  | 보조 인덱스 | - 클러스터 인덱스가 아닌 모든 인덱스는 보조 인덱스이며 보조 인덱스의 각 레코드는 보조 인덱스 속성과 기본키 속성 값을 갖고 있다.
- 보조 인덱스를 검색하여 기본키 속성 값을 찾은 다음 클러스터 인덱스로 가서 해당 레코드를 찾는다. |

### 4. 인덱스의 생성

- 인덱스 생성 고려사항
  - 인덱스는 WHERE절에 자주 사용되는 속성이어야 한다.
  - 인덱스는 조인에 자주 사용되는 속성이어야 한다.
  - 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다.
  - 속성이 가공되는 경우 사용하지 않는다.
  - 속성의 선택도가 낮을 때 유리하다(속성의 모든 값이 다른 경우)

```sql
CREATEE [UNIQUE] INDEX [인덱스이름]
ON 테이블이름 (컬럼 [ASC | DESC] [{, 컬럼 [ASC | DESC]} ...])[;]
```

- 생성된 인덱스는 SHOW INDEX 명령어로 확인 가능

```sql
SHOW INDEX FROM Book;
```

### 5. 인덱스의 재구성과 삭제

- 인덱스의 재구성은 ANALYZE TABLE 명령을 사용하여 수행한다.

```sql
ANALYZE TABLE 테이블이름;
```

- 인덱스의 삭제는 DROP INDEX 명령을 사용한다.

```sql
DROP INDEX ix Book ON Book;
```
