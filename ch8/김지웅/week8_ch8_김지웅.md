# CHAPTER 8 트랜잭션, 동시성 제어, 회복
## 트랜잭션
### 트랜잭션의 개념
- 트랜잭션은 DBMS에서 데이터를 다루는 논리적인 작업의 단위
- 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우 장애 발생 시 데이터를 복구하는 작업의 단위
- 데이터베이스에서 여러 작업이 동시에 같 은 데이터를 다룰 때 작업을 서로 분리하는 단위
- 정보의 흐름 : 하드디스크 - 주기억장치 버퍼 - 하드디스크
- 트랜잭션의 수행 과정 : 시작 - 수행 - 부분완료 - 버퍼내용기록 - 완료
### 트랜잭션의 성질
- 원자성 : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야함
- 일관성 : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야함
- 고립성 : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야함
- 지속성 : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야함
#### 원자성
- 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미
| 표준 명령어 | 문법 | 설명 |
| --- | --- | --- |
| START TRANSACTION | SET TRANSACTION | 트랜잭션의 시작 |
| COMMIT | COMMIT | 트랜잭션의 종료 |
| ROLLBACK | ROLLBACK {TO <savepoint>} | 트랜잭션을 전체 혹은 <savepoint>까지 무효화시킴 |
| SAVE | SAVEPOINT <identifier> | <savepoint>를 만듦 |

#### 일관성
- 테이블이 생성돌 때 CREATE 문과 ALTER 문의 무결성 제약조건을 통해 명시됨

#### 고립성
- 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상
- 고립성을 유지하기 위해서는 변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할 때 제어하는 작업이 필요

#### 지속성
- 트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야함
- 부분완료 : 트랜잭션 수행은 완료되었지만 변경 내용이 데이터베이스에 기록되었는지 확실하지 않은 상태
- 실패 : 트랜잭션을 중간에 중단하였거나 부분완료 상태에서 변경 내용을 데이터베이스에 저장하지 못한 상태

### 트랜잭션과 DMBS
- DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용한다.
- DBMS는 고립성을 유히자기 위해 일관성을 유지하는 것과 마찬가지로 동시성 제어 알고리즘을 작동시킨다.
- DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용한다.
- 무결성 제약조건 : 일관성<br>동시성 제어 : 일관성, 고립성<br>회복 : 원자성, 지속성

## 동시성 제어
- 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

### 갱신손실 문제
- 갱신손실 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생
- 작업 설명 : 하나의 데이터에 두 트랜잭션이 접근하여 갱신하는 작업<br>시나리오 : 두 개의 트랜잭션이 동시에 작업을 진행<br>문제 발생 : 갱신손실

### 락
- 갱신손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요
- 자신이 데이터를 수정 중이라는 사실을 알리면 되는데 그 방법이 락

#### 락의 개념
- 락 : 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금장치

#### 락의 유형
- 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기상태로 만듬
- 데이터 읽기를 표시하는 락은 공유락, 데이터 읽기/쓰기를 할 때 사용하는 락은 배타락

#### 2단계 락킹
- 데이터에 락을 걸었다 풀고 다시 거는 중간 과정에 락의 해지 상태가 생기면서 다른 트랜잭션에게 중간 결과를 보일 수 있는 걸 방지하기 위해 2단계 락킹사용
- 확장단계 : 트랜잭션이 필요한 락을 획득하는 단계, 이 단계에서는 이미 획득한 락을 해제하지 않음
- 수축단계 : 트랜잭션이 락을 해제하는 단계, 이 단계에서는 새로운 락을 획득하지 않음

#### 데드락
- 2단계 락킹 기법을 사요여하면 데이터의 일관성을 유지할 수 있지만 두개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있음

## 트랜잭션 고립 수준
- 오손 읽기 : 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제<br>작업 중인 트랜잭션 2가 어떤 이유로 작업을 철회할 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출, 이것이 오손 읽기

- 반복불가능 읽기 : 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제, 읽기 작업을 반복할 경우 이전의 결과가 반복되지 않는 현상

- 유령 데이터 읽기 : 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제, 다시 한 번 작업을 반복할 경우 이전에 없던 데이터가 나타나는 현상
### 트랜잭션 고립 수준 명령어

| 고립수준\문제 | 오손 읽기 | 반복불가능 읽기 | 유령데이터 읽기 |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 가능 | 가능 | 가능 |
| READ COMMITTED | 불가능 | 가능 | 가능 |
| REPEATABLE READ | 불가능 | 불가능 | 가능 |
| SERIALIZABLE | 불가능 | 불가능 | 불가능 |

#### READ UNCOMMITTED(LEVEL=0)
- 고립 수준이 가장 낮음

| 모드 | READ UNCOMMITTED |
| --- | --- |
| LOCK | SELECT 문 - 공유락 걸지 않음<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션의 공유락과 배타락이 걸린 데이터를 읽음 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED |
| 문제점 | 오손읽기, 반복불가능 읽기, 유령데이터 읽기 |

#### READ COMMITTED(LEVEL=1)
| 모드 | READ COMMITTED |
| --- | --- |
| LOCK | SELECT 문 - 공유락을 걸고 끝나면 바로 해지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL READ COMMITTED |
| 문제점 | 반복불가능 읽기, 유령데이터 읽기 |

#### REPEATABLE READ(LEVEL=2)
| 모드 | REPEATABLE READ |
| --- | --- |
| LOCK | SELECT 문 - 공유락을 걸고 트랜잭션 끝까지 유지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL REPEATABLE READ |
| 문제점 | 유령데이터 읽기 |

#### SERIALIZABLE(LEVEL=3)
| 모드 | SERIALIZABLE |
| --- | --- |
| LOCK | SELECT 문 - 공유락을 걸고 트랜잭션 끝까지 유지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함<br>인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT 문이 금지됨 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL SERIALIZABLE |
| 문제점 | 없음 |

## 회복
- 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능
- 시스템 충돌 : 하드웨어 혹은 소프트웨어의 오류로 주기억장치가 손실되는 것을 말함.<br>처리 중인 프로그램과 데이터의 일부 혹은 전부가 손실됨
- 미디어 장애 : 헤드 충돌이나 읽기 장애로 보고기억장치가 손실되는 것을 말함.<br>보조기억장치에 저장 중인 데이터의 일부 혹은 전부가 손실됨
- 응용 소프트웨어 오류 : 데이터베이스에 접근하는 소프트웨어의 논리적인 오류로 트랜잭션의 수행이 실패하는 것을 말함
- 자연재해 : 화재, 홍수, 지진, 정전 등에 의해 컴퓨터 시스템이 손상되는 것을 말함
- 부주의 혹은 태업 : 운영자나 사용자의 부주의로 데이터가 손실되거나 의도적인 손상을 입는 것

### 트랜잭션과 회복
- 트랜잭션은 데이터베이스 회복의 단위임
- 트랜잭션은 데이터의 변경 내용을 한순간에 모두 데이터베이스에 기록하지 않음
- DBMS의 회복 관리자는 트랜잭션의 ACID 성질 중 우너자성과 지속성을 보장하여 장애로부터 DB를 보호

### 로그 파일
- DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 DB 손실을 방지하기 위해 트랜잭션의 DB 기록을 추적하는 로그파일 사용
- 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록 해두는 별도의 DB

### 로그 파일을 이용한 회복
- 시스템 운영 중 장애가 발생 시 DBMS는 로그 파일을 먼저 살핌
- 트랜잭션이 종료 혹은 중단됐는지 판단 후 REDO와 UNDO를 진행
- 트랜잭션의 재실행(REDO) : 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정
- 트랜잭션의 취소(UNDO) : COMMIT 연산이 로그에 보이지 않는다는 것은 트랜잭션이 완료되지 못했다는 의미로, 트랜잭션이 한 일을 모두 취소하는데 이 때 로그를 보면서 트랜잭션이 변경한 내용을 DB에서 원상복구시키는 과정
- 즉시갱신 : 버퍼 - 로그파일, 버퍼 - 데이터베이스 작업이 부분완료 전에 동시에 진행될 수 있음
- 지연갱신 : 버퍼 - 로그파일이 모두 끝난 후 부분완료를 하고 이후 버퍼 - 데이터베이스 작업을 진행하는 방법

### 체크포인트를 이용한 회복
- 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장
- 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장(즉시갱신 경우)
- 체크포인트를 로그 파일에 표시